"""
pyAirtable exposes a command-line interface that allows you to interact with the API.
"""

import functools
import json
import os
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Callable, Optional, Sequence

from typing_extensions import ParamSpec, TypeVar

from pyairtable.api.api import Api
from pyairtable.api.base import Base
from pyairtable.api.table import Table
from pyairtable.models._base import AirtableModel
from pyairtable.orm.generate import ModelFileBuilder
from pyairtable.utils import is_table_id

try:
    import click
except ImportError:  # pragma: no cover
    print(
        "You are missing the 'click' library, which means you did not install\n"
        "the optional dependencies required for the pyairtable command line.\n"
        "Try again after running:\n\n"
        "   % pip install 'pyairtable[cli]'",
        "\n",
        file=sys.stderr,
    )
    raise


T = TypeVar("T")
F = TypeVar("F", bound=Callable[..., Any])
P = ParamSpec("P")


@dataclass
class CliContext:
    access_token: str = ""
    base_id: str = ""
    table_id_or_name: str = ""
    click_context: Optional["click.Context"] = None

    @functools.cached_property
    def api(self) -> Api:
        return Api(self.access_token)

    @functools.cached_property
    def base(self) -> Base:
        return self.api.base(self.base_id)

    @functools.cached_property
    def table(self) -> Table:
        return self.base.table(self.table_id_or_name)

    @property
    def click(self) -> click.Context:
        assert self.click_context is not None
        return self.click_context

    def default_subcommand(self, cmd: F) -> None:
        if not self.click.invoked_subcommand:
            self.click.invoke(cmd)


def needs_context(func: Callable[P, T]) -> Callable[P, T]:
    @functools.wraps(func)
    @click.pass_context
    def _wrapped(click_ctx: click.Context, /, *args: P.args, **kwargs: P.kwargs) -> T:
        obj = click_ctx.ensure_object(CliContext)
        obj.click_context = click_ctx
        return click_ctx.invoke(func, obj, *args, **kwargs)

    return _wrapped


# fmt: off
@click.group()
@click.option("-k", "--key", help="Your API key.")
@click.option("-kf", "--key-file", type=click.Path(exists=True), help="File containing your API key.")
@click.option("-ke", "--key-env", metavar="VAR", help="Env var containing your API key.")
@needs_context
# fmt: on
def cli(
    ctx: CliContext,
    key: str = "",
    key_file: str = "",
    key_env: str = "",
) -> None:
    if not any([key, key_file, key_env]):
        try:
            key_file = os.environ["AIRTABLE_API_KEY_FILE"]
        except KeyError:
            try:
                key = os.environ["AIRTABLE_API_KEY"]
            except KeyError:
                raise click.UsageError("--key, --key-file, or --key-env required")

    if len([arg for arg in (key, key_file, key_env) if arg]) > 1:
        raise click.UsageError("only one of --key, --key-file, --key-env allowed")

    if key_file:
        with open(key_file) as inputf:
            key = inputf.read().strip()

    if key_env:
        key = os.environ[key_env]

    ctx.access_token = key


@cli.command()
@needs_context
def whoami(ctx: CliContext) -> None:
    """
    Print information about the current user.
    """
    _dump(ctx.api.whoami())


@cli.command()
@needs_context
def bases(ctx: CliContext) -> None:
    """
    List all available bases.
    """
    _dump(ctx.api._base_info().bases)


@cli.group(invoke_without_command=True)
@click.argument("base_id")
@needs_context
def base(ctx: CliContext, base_id: str) -> None:
    """
    Print information about a base.
    """
    ctx.base_id = base_id
    ctx.default_subcommand(base_schema)


@base.command("schema")
@needs_context
def base_schema(ctx: CliContext) -> None:
    """
    Print the base schema.
    """
    _dump(ctx.base.schema())


@base.command("orm")
@needs_context
@click.option(
    "-t",
    "--table",
    help="Only generate specific table(s).",
    metavar="NAME_OR_ID",
    multiple=True,
)
def base_orm(ctx: CliContext, table: Sequence[str]) -> None:
    """
    Print a Python module with ORM models.
    """
    table_ids = [t for t in table if is_table_id(t)]
    table_names = [t for t in table if not is_table_id(t)]
    generator = ModelFileBuilder(ctx.base, table_ids=table_ids, table_names=table_names)
    now = datetime.now(timezone.utc).isoformat()
    print("# This file was generated by pyAirtable at", now)
    print("# Any modifications to this file will be lost if it is rebuilt.")
    print()
    print(str(generator))


@base.group("table", invoke_without_command=True)
@needs_context
@click.argument("id_or_name")
def base_table(ctx: CliContext, id_or_name: str) -> None:
    """
    Print information about a table.
    """
    ctx.table_id_or_name = id_or_name
    ctx.default_subcommand(base_table_schema)


@base_table.command("records")
@needs_context
# fmt: off
@click.option("-f", "--formula", help="Filter records with a formula.")
@click.option("-v", "--view", help="Filter records by a view.")
@click.option("-n", "--limit", "max_records", type=int, help="Limit the number of records returned.")
@click.option("-S", "--sort", help="Sort records by field(s).", multiple=True)
@click.option("-F", "--field", "fields", help="Limit output to certain field(s).", multiple=True)
# fmt: on
def base_table_records(
    ctx: CliContext,
    formula: Optional[str],
    view: Optional[str],
    max_records: Optional[int],
    fields: Sequence[str],
    sort: Sequence[str],
) -> None:
    """
    Retrieve records from the table.
    """
    fields = list(fields)
    sort = list(sort)
    _dump(
        ctx.table.all(
            formula=formula,
            view=view,
            max_records=max_records,
            fields=fields,
            sort=sort,
        )
    )


@base_table.command("schema")
@needs_context
def base_table_schema(ctx: CliContext) -> None:
    """
    Print a JSON representation of the table schema.
    """
    _dump(ctx.table.schema())


class JSONEncoder(json.JSONEncoder):
    def default(self, o: Any) -> Any:
        if isinstance(o, AirtableModel):
            return o._raw
        return super().default(o)  # pragma: no cover


def _dump(obj: Any) -> None:
    print(json.dumps(obj, cls=JSONEncoder))


if __name__ == "__main__":
    cli()  # pragma: no cover
