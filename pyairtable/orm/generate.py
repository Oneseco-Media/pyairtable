"""
pyAirtable can generate ORM models that reflect the schema of an Airtable base.
"""

import datetime
import re
from dataclasses import dataclass
from functools import cached_property
from typing import Any, Dict, List, Optional, Sequence, Type

import inflection

from pyairtable.api.base import Base
from pyairtable.api.table import Table
from pyairtable.models import schema as S
from pyairtable.orm import fields


class ModelFileBuilder:
    def __init__(self, base: Base, table_names: Optional[Sequence[str]] = None):
        tables = base.tables()
        if table_names:
            tables = [t for t in tables if t.name in table_names]
        self.model_builders = [ModelBuilder(self, table) for table in tables]

    @cached_property
    def model_lookup(self) -> Dict[str, "ModelBuilder"]:
        return {
            key: builder
            for builder in self.model_builders
            for key in (builder.table.id, builder.table.name)
        }

    def __str__(self) -> str:
        now = datetime.datetime.now().isoformat()
        models_expr = "\n\n\n".join(str(builder) for builder in self.model_builders)
        import_exprs = [
            "import os",
            "from functools import partial",
            "from typing import Any" if "[Any]" in models_expr else "",
            "from typing import Union" if "[Union[" in models_expr else "",
        ]
        preamble = "\n".join(
            [
                f"# This file was generated by pyairtable.orm.generate at {now}.",
                "# Any modifications to this file will be lost if it is rebuilt.",
                "",
                "from __future__ import annotations",
                "",
                *(line for line in import_exprs if line),
                "",
                "from pyairtable.orm import Model",
                "from pyairtable.orm import fields as F",
            ]
        )
        all_expr = "\n".join(
            [
                "__all__ = [",
                *sorted(f"    {b.class_name!r}," for b in self.model_builders),
                "]",
            ]
        )
        return "\n\n\n".join([preamble, models_expr, all_expr])


@dataclass
class ModelBuilder:
    file_generator: ModelFileBuilder
    table: Table

    @property
    def field_builders(self) -> List["FieldBuilder"]:
        return [
            FieldBuilder(field_schema, lookup=self.file_generator.model_lookup)
            for field_schema in self.table.schema().fields
        ]

    @property
    def class_name(self) -> str:
        name = inflection.singularize(self.table.schema().name)
        name = re.sub(r"[^a-zA-Z0-9]+", " ", name)
        return "".join(part.capitalize() for part in name.split())

    def __str__(self) -> str:
        return "\n".join(
            [
                f"class {self.class_name}(Model):",
                "    class Meta:",
                "        api_key = partial(os.environ.get, 'AIRTABLE_API_KEY')",
                f"        base_id = {self.table.base.id!r}",
                f"        table_name = {self.table.schema().name!r}",
                "",
                *(f"    {fg}" for fg in self.field_builders),
            ]
        )


@dataclass
class FieldBuilder:
    schema: S.FieldSchema
    lookup: Dict[str, ModelBuilder]

    @property
    def var_name(self) -> str:
        name = re.sub(r"[^a-zA-Z0-9]+", " ", self.schema.name)
        name = name.strip().lower().replace(" ", "_")
        return name

    @property
    def field_class(self) -> Type[fields.AnyField]:
        field_type = self.schema.type
        if isinstance(self.schema, (S.FormulaFieldSchema, S.RollupFieldSchema)):
            if self.schema.options.result:
                field_type = self.schema.options.result.type
        return fields.FIELD_TYPES_TO_CLASSES[field_type]

    def __str__(self) -> str:
        args: List[Any] = [self.schema.name]
        kwargs: Dict[str, Any] = {}
        generic = ""

        if isinstance(self.schema, S.MultipleLookupValuesFieldSchema):
            generic = f"[{_lookup_field_type_annotation(self.schema)}]"

        if isinstance(self.schema, S.MultipleRecordLinksFieldSchema):
            linked_model = self.lookup[self.schema.options.linked_table_id]
            kwargs["model"] = linked_model.class_name
            generic = f"[{linked_model.class_name!r}]"

        if self.schema.type in ("formula", "rollup"):
            kwargs["readonly"] = True

        args_repr = [repr(arg) for arg in args]
        args_repr.extend(f"{k}={v!r}" for (k, v) in kwargs.items())
        args_join = ", ".join(args_repr)
        return f"{self.var_name} = F.{self.field_class.__name__}{generic}({args_join})"


def _lookup_field_type_annotation(schema: S.MultipleLookupValuesFieldSchema) -> str:
    if not schema.options.result:
        return "Any"
    lookup_type = schema.options.result.type
    if lookup_type == "multipleRecordLinks":
        return "str"  # otherwise this will be 'list'
    cls = fields.FIELD_TYPES_TO_CLASSES[lookup_type]
    if isinstance(contained_type := getattr(cls, "contains_type", None), type):
        return contained_type.__name__
    valid_types = _flatten(cls.valid_types)
    if len(valid_types) == 1:
        return valid_types[0].__name__
    return "Union[%s]" % ", ".join(t.__name__ for t in _flatten(cls.valid_types))


def _flatten(class_info: fields._ClassInfo) -> List[Type[Any]]:
    if isinstance(class_info, type):
        return [class_info]
    flattened = [t for t in class_info if isinstance(t, type)]
    for t in class_info:
        if isinstance(t, tuple):
            flattened.extend(_flatten(t))
    return flattened
